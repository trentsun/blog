{"pages":[],"posts":[{"title":"A Good Start","text":"2020年已经结束半个月, 现在来补个总结。 深圳之行 寒假还没开始， 疫情在武汉蔓延开来，我选择去深圳和爷爷一起度过这个春节。在这之前我参与了一个项目，工期很赶，所以只准备去5天就回学校。结果疫情突然变得严重， 学校宣布禁止返校，项目被迫只能停工。我也就直接在深圳住了下来，渐渐融入了这里的生活。一天，站在莲花山顶眺望南山，也许以后就会去那里工作生活，我开玩笑似的和家人说，（这也是这个寒假再次来到深圳的原因之一）。 第一次比赛 在6月份接近尾声的时候，比赛网申开始了，我们积极准备材料进行答辩，虽然过程很坎坷， 最终也拿到了不错的成绩，大家都很满意自己的结果。这是第一次参加团队比赛，从开始的一无所有到后来队伍逐渐扩大，项目慢慢有了起色，大家磨合的越来越好，每个人都从中得到了自己想要的东西。可惜之后学校调整了保研政策， 我也受到影响，开始从新考虑就业这条道路。 实习之路 在4、5月份的时候，第一次投递实习，因为自己准备的太仓促，实力又很弱，很遗憾错过了实习的机会。在11月份的时候，开始重新准备寒假的实习，背了不少八股文，也刷了300题leetcode。经过几次面试之后，感觉自己掌握了面试的节奏，以后也要经常去面试，保证自己的状态。最终很幸运拿了鹅厂的offer又一次去了深圳。 杂谈 刚进大学的时候, 被分到和大三的学长一个寝室, 我对他们的生活状态, 学习氛围向往不已：每个人都忙于自己的学习工作；晚上会寝室一起开黑打lol；熄灯之后一起吹吹牛；当时猜想自己的大学生活也会这么的美好。现在我也到了这个节点，再一次体会当时学长的生活，确是不一样的感觉~ 未来 To be continued!","link":"/2021/01/17/A-Good-Start/"},{"title":"Java内存模型","text":"as-if-serial属性 菩提本无树, 何处惹尘埃。 即时编译器(和处理器)需要保证程序能够遵守as-if-serial属性。通俗地说, 就是在单线程情况下, 要给程序一个顺序执行的假象。即经过重排序的执行结果要与顺序执行的结果一致。 另外, 若两个操作之间存在数据依赖, 那么及时编译器(和处理器)不能调整它们的顺序, 否则将会造成程序语义的改变。 happens-before 关系 问渠那得清如许? 唯有源头活水来。 描述两个操作的内存可见性的。如果操作X happens-before 操作Y, 那么X的结果对于Y可见(Y观测X的结果) Java内存模型定义的线程间happens-before关系 1。解锁操作 happens-before 对该所锁的加锁操作(时序)2。volatile字段的写操作 happens-before 对该volatile字段的读操作(时序)3。线程的启动(start) happens-before 线程的第一个操作4。线程的最后一个操作 happens-before 线程的终止事件(即其他线程通过Thread.isAlive() 或 Thread.join()判断该线程是否中止)5。线程对其他线程的中断操作 happens-before 被中断线程收到的中断事件(即被中断线程的InterruptedException异常, 或者第三个线程针对被中断线程的Thread.interrupted 或者 Thread.isinterrupted调用)6。构造器中的最后一个操作 happens-before 析构器的第一个操作 另外happens-before关系还具备传递性. Java内存模型的底层实现 Java内存模型是通过内存屏障(memory barrier)来禁止重排序的. 对于即使编译器来说, 它会针对每个happens-before 关系, 向正在编译的目标方法中插入相应的读读,读写,写读,写写内存屏障。 这些内存屏障会限制即时编译器的重排序操作。以volatile字段访问为例, 所插入的内存屏障将不允许volatile字段写操作之前的内存访问被重排序至其后; 也将不允许bolatile字段读操作之后的内存访问被重排序至之前。volatile字段的内存屏障是什么类型? 即时编译器会根据具体的底层体系架构, 将内存屏障替换成具体的CPU指令。以我接触最多的X86_64架构来说, 读读,读写以及写写内存屏障是空操作(no-op), 只有写读内存屏障会被替换成具体指令 这样理解重排序Java代码本应该按源码顺序执行, 但是编译器对部分代码会进行优化, 提高执行效率(cpu 或 内存) 然而, 禁止重排序是处于某种目的(业务逻辑/happens-before)开发人员对编译器的代码重排序进行一定的限制。 对于即时编译器来说, 它会针对happens-before关系, 向正在编译的目标方法中插入相应的内存屏障(读读,读写,写读,写写) volatilevolatile字段写操作之后的写读内存屏障需要用具体指令来替代.(HotSpot 所选取的具体指令是 lock add DWORD PTR[rsp],0x0, 而非mfence[3].)在具体指令的效果, 可以简单理解为强制刷新处理器的写缓存。写缓存是处理器用来加速内存存储效率的一项技术。在碰到内存写操作时, 处理器并不会等待该指令结束, 而是直接开始下一指令, 并且依赖于写缓存将更改的数据同步至主内存之中。强制刷新写缓存,将使得当前线程写入volatile字段的值(以及写缓存中已有的其他内存修改), 同步至主内存之中。强制刷新写缓存, 将是得当前现成写入volatile字段的值(以及写缓存中已有的其他内存修改), 同步至主内存之中。由于内存写操作(强制刷新缓存)同时会无效化其他处理器所持有的指向同一内存地址的缓存行, 因此可以认为其他处理器能够立即见到该volatile字段的最新值。 锁前面提到锁具备happens-before关系。具体来说, 解锁操作happens-before之后对同一把锁的枷锁操作。实际上, 在解锁时, Java虚拟机同样需要强制刷新缓存, 使得当前线程所修改的内存对其他线程可见。锁操作具备happens-before关系。具体来说, 解锁操作happens-before之后对同一把锁。也就是说, 如果编译器能够(通过逃逸分析)证明某把锁仅被同一线程持有, 那么它可以移除相应的加锁解锁操作。 finalfinal实例字段涉及新建对象的发布问题。当一个对象包含final实例字段时, 我们希望其他线程智能看到已初始化的实例字段。 因此, 即时编译器会在final字段的写操作后插入一个写写屏障, 以防某些优化将新建对象的发布(即将实例对象写入一个共享引用中) 重排序至final字段的写操作之前。在X86_64平台上, 写写屏障是空操作 新建对象的安全发布问题(safe publication)问题不仅仅包括final实例字段的可见性, 还包括其他实例字段的可见性。 https://vlkan.com/blog/post/2014/02/14/java-safe-publication/","link":"/2020/03/10/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"title":"Java反射API的用法","text":"获取Class对象 Class.forName获取Class对象 getClass()方法 直接使用类名+”.class”. 对于基本数据类型, 它们的包装类型拥有一个名为”TYPE”的final静态字段, 指向该基本数据类型对应的Class对象 integer.TYPE 指向 int.class对于数组类型 可以使用类名+ “[].class”来访问, 如int[].class 拿到Class对象后 使用newInstance()生成一个实例(需要一个无参构造器) 使用isInstance(Object)来判断一个对象是否是该类的实例, 语法上等同于instance of 关键字(JIT 优化时会有差别?) 使用Array.newInstance(Class,int)来构造该类型的数组 使用getFIelds()/getConstructors()/getMethods() 来访问该类型的成员. 带Declared的方法不会返回父类成员,但是会返回私有成员 拿到类成员后 使用Constructor/Field/Method.setAccessible(true)来绕开Java语言的访问限制(如private). 使用Constructor.newInstance(Object[])来生成该类的实例 使用Field.get/set(Objcet)访问字段 使用Method.invoke(Object, Object[])来调用方法 反射调用栈 默认情况下反射调用为委派实现, 委派给本地实现来进行方法实现来进行方法调用. 在达到阈值超过15次(第15次)委派实现会将委派对象DelegatingMethodAccessorImpl切换至动态实现(自动生成字节码(耗时)), 它将直接使用invoke指令来调用目标方法 反射性能开销原因 不定长参数导致的Object数组 基本数据类型的自己装箱拆箱 方法内联 (将本方法内调用的方法与自己一起编译)","link":"/2020/02/22/Java%E5%8F%8D%E5%B0%84API%E7%9A%84%E7%94%A8%E6%B3%95/"},{"title":"Java对象的内存布局","text":"java对象的额外内存开销(对象头)运行数据 (8字节)包括 哈希码 GC信息 所信息 对象类型指针 (8字节) 指向对象对应的类 压缩指针 通过 jvm命令选项开启 -XX:+UseCompressedOops这里针对对象类型指针, 实际上对所有引用指针起作用 对于64位java虚拟机 64位 -&gt; 32位因此java对象的额外内存开销为12字节 内存对齐 通过jvm选项 -XX:ObjectAlignmentlnBytes开启进一步提升了寻址范围. 同时也有可能增加对象间内存填充, 倒置压缩指针没有到达原本节省空间的效果. 对象内存对齐对象内字段内存对齐java虚拟机要求long字段,double字段以及非压缩指针状态下的引用字段地址为8的倍数 do for what? 让字段支出现在同一CPU的缓存行种. 如果字段不是对齐的, 那么可能出现跨缓存行的字段. 该对象的读取可能需要替换两个缓存行, 该字段的存储也会同时污染来那个缓存行. 对程序的执行效率不利. 字段重排列 通过jvm选项 -XX:FieldsAllocationStyle(默认为1)开启java虚拟机重新分配源代码中声明的字段先后顺序, 以达到内存对齐的目的. 规则 如果字段占据C个字节, 那么该字段的偏移量需要对齐至NC. 这里偏移量指的是字段起始地址与对象的起始地址的差值 例如: Long类型有一个long字段, 在使用了压缩指针的64位虚拟机中 1long字段的地址 = n*16 + 对象起始地址 (n=1) 子类所继承的偏移量, 需要与父类的对应字段一致在具体实现中，Java 虚拟机还会对齐子类字段的起始位置。对于使用了压缩指针的 64 位虚拟机，子类第一个字段需要对齐至 4N；而对于关闭了压缩指针的 64 位虚拟机，子类第一个字段则需要对齐至 8N。 class A { long l; int i；} class B extends A { long l; int i;}我在文中贴了一段代码，里边定义了两个类 A 和 B，其中 B 继承 A。A 和 B 各自定义了一个 long 类型的实例字段和一个 int 类型的实例字段。下面我分别打印了 B 类在启用压缩指针和未启用压缩指针时，各个字段的偏移量。 启用压缩指针时，B 类的字段分布B object internals: 123456789OFFSET SIZE TYPE DESCRIPTION 0 4 (object header) 4 4 (object header) 8 4 (object header) 12 4 int A.i 0 16 8 long A.l 0 24 8 long B.l 0 32 4 int B.i 0 36 4 (loss due to the next object alignment) 当启用压缩指针时，可以看到 Java 虚拟机将 A 类的 int 字段放置于 long 字段之前，以填充因为 long 字段对齐造成的 4 字节缺口。由于对象整体大小需要对齐至 8N，因此对象的最后会有 4 字节的空白填充。 关闭压缩指针时，B 类的字段分布B object internals: 1234567891011OFFSET SIZE TYPE DESCRIPTION 0 4 (object header) 4 4 (object header) 8 4 (object header) 12 4 (object header) 16 8 long A.l 24 4 int A.i 28 4 (alignment/padding gap) 32 8 long B.l 40 4 int B.i 44 4 (loss due to the next object alignment) 当关闭压缩指针时，B 类字段的起始位置需对齐至 8N。这么一来，B 类字段的前后各有 4 字节的空白。那么我们可不可以将 B 类的 int 字段移至前面的空白中，从而节省这 8 字节呢？ 是可以节省的, 这可能是一个历史遗留问题 虚共享问题 两个线程分别访问同一个对象中不同的volatile字段, 逻辑上它们并没有共享内容, 因此不需要同步.然而, 如果这两个字段恰好在同一个缓存行中, 那么对这些字段的写操作会导致缓存行的写会, 造成了实质上的共享. java虚拟机会让不同的@Contended字段之间处于独立的缓存行, 因此造成大量空间浪费, 具体的分布算法属于实现细节. 通过jvm选项-XX:-RestrictContended查阅Contended字段的内存布局(if java version &gt; 9 编译时需要–add-exports java.base/jdk.internal.vm.annotation=ALL-UNNAME)","link":"/2020/02/21/Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"},{"title":"Java工具集LTS","text":"使用javap来查看字节码 默认情况下打印所有非私有方法和字段 -p选项 还会打印私有方法和字段 -v选项 尽可能打印所有信息(这里指) -c选项 只查看方法对应字节码 JOL工具 12curl -L -O http://central.maven.org/maven2/org/openjdk/jol/jol-cli/0.9/jol-cli-0.9-full.jarjava -cp jol-cli-0.9-full.jar org.openjdk.jol.Main internals java.lang.String jol地址已失效 -&gt; 新地址 jvm调试命令-XX:+ -XX:+UseCompressedOops 开启对象压缩指针 64位 -&gt; 32 位 这里使用内存对齐(8位)使后三位为0, 也可以用这3位来记录一些额外信息 扩大寻址范围32位-&gt;35位. -XX:ObjectAlignmentLnBytes 字节对齐 java虚拟机堆中的起始地址需要对齐至8的倍数 对象之间有内存对齐, 对象之间的字段也需要内存对齐(否则, 字段的读取需要替换两个缓存行, 存储会同时污染来那个缓存行, 影响执行效率) jps 打印所有正在运行的进程的相关信息。 帮助文档 -m 将打印传递给Java虚拟机的参数 -l 将打印模块名以及包名 -v 将打印传递给 Java 虚拟机的参数（如-XX:+UnlockExperimentalVMOptions -XX:+UseZGC） jstat 打印目标Java进程的性能数据。 帮助文档$ jstat -options-class-compiler-gc-gccapacity-gccause-gcmetacapacity-gcnew-gcnewcapacity-gcold-gcoldcapacity-gcutil-printcompilation 例： 1jstat -gc -t 22126 1s 4 jmap 分析虚拟机堆中的对象 帮助文档-clstats-finalizerinfo-histo-dump 例： 1jmap -histo 22574 注意 以及jinfo、jstack和jcmd依赖于Java虚拟机的Attach API，因此只能监控本地Java进程一旦开启Java虚拟机参数DisableAttachMechanism（-XX:+DisableAttachMechanism)，基于Attach API的命令将无法执行。 远程跑java程序是否可以使用这些工具？ jinfo jinfo命令可用来查看目标Java进程的参数，如传递给Java虚拟机的-X(即输出中的VM Flags），以及可在Java层面通过System.getProperty获取的-D参数（即输出中的System Properties）。可以改动manageable的参数 帮助文档例: 1jinfo 73269 jstack jstack命令可以用来打印目标Java进程中各个线程的栈轨迹，以及这些线程所持有的锁。 帮助文档jstack的其中一个应用场景便是死锁检测。jstack不仅会打印线程的栈轨迹、线程状态（BLOCKED）、持有的锁（locked …）以及正在请求的锁（waiting to lock …），而且还会分析出具体的死锁。 例： 1jstack 73269 jcmd 可以使用jcmd命令，来代替除了jstat之外的所有命令。 帮助文档","link":"/2020/02/21/Java%E5%B7%A5%E5%85%B7%E9%9B%86LTS/"},{"title":"MacOs catalina 配置zsh别名和主题","text":"zsh主题1234autoload -Uz promptinit promptinit prompt -l //列出主题prompt walters 在命令行中用过后添加一下内容(当中的fade是一个主题)到 ~/.zshrc 之后source一下,就配置到zsh了 123autoload -Uz promptinitpromptinitprompt fade &quot;red&quot; zsh配置别名配置文件 ~/.zshrc配置方式例如: 12alias zshconfig=&quot;vim ~/.zshrc&quot;alias -s py=vi #在命令行输入python文件,会用vim打开 再source一下","link":"/2019/12/01/MacOs-catalina-%E9%85%8D%E7%BD%AEzsh%E5%88%AB%E5%90%8D%E5%92%8C%E4%B8%BB%E9%A2%98/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/03/11/hello-world/"},{"title":"java入门学习","text":"Java (c++-)学习笔记 day1 4/14 2019 Java 核心优势:跨平台/可移植性Java 各个版本javaEE(Java Enterprise Edition):企业版:定位在服务器上的应用&lt;br&gt; JavaME:微型版----会被安卓取代&lt;br&gt; JavaSE==:(Java Sandard Edition) :标准版:定位在个人计算机的应用&lt;br&gt; Java 特点简单,分布式,多线程,高性能,健壮 JVM/JRE/JDKJVM(Java Virtual Machine)虚拟机执行字节码 JRE(Java Runtime Environment) :包含jvm,库函数,必须文件 JDK(Java Development Kit):包含Jre day2 4/15 2019 抽象类和抽象方法 1.有抽象方法的类只能是抽象类 2.抽象类不能实例化(不能用new实例化抽象类),可以用子类实例 3.抽象类可以包含属性、方法、构造方法,但是构造方法不能用来new实例,只能用来被子类调用 4.抽象类只能被继承 5.抽象方法必须被子类实现接口和多继承接口interface(接口就是规范) 方法全部为抽象方法 变量全为常量 支持多继承 不能创建实例 ,但是可以用于引用变量类型 jdk1.8后包含普通的静态方法实现implement(类似extends)内部类非静态内部类 day3 4/16 2019 容器类 collection 容器(集合) List 有顺序,可重复 ArrayList LinkedList Set 无顺序,不可重复 HashSet Map 键值对 HashMap TreeMap collection 方法 123456789101112add()toArrary()isempty()remove()contains()size()clear()-----------------------------------addAll()containsAll()removeAll()retainAll() set方法和collection基本相同 set 不允许`e1.equals(e2)==true`的对象放入List 有序:List中每个元素都有索引标记 可重复:允许加入重复的元素 ArrayList(数组)123456789indexOf() 返回第一次出现的对象的索引值 lastIndex() 返回最后一次出现的对象的索引值copyOf(elementData , int)copyadd(E)add(int,E)remove(int)System.arraycopy(elementData ,index+1,elementData,index)clear() LinkedList(链表)Vector(线程安全的数组)泛型 Java中泛型的引入是通过泛型擦除机制来实现的泛型只在编译中被编译器javac识别&amp;使用，用来确保数据的安全性&amp;免去强制类型转换的麻烦。 可以用继承的方式限制参数类型 extends Number类可以起到c#中 where T:struct的作用 day4 4/27 2019 Java异常类型机制类结构 Thrwoable Error Exception CheckedException RuntimeException uncheckExceptionRutimeException 运行时异常由JRE抛出通常需要程序员去修改 checkedException 由编译器处理，在编译时会及时报错 处理方法 try catch finally 语法格式 向外抛出，一直到抛到JRE day5 4/29 2019 注解注释是给人程序员看的，注解是给给程序看的 @Override：重写 @Deprecated：过时 @Suppress warning：压制警告元注解 注释注解用的@Target修饰注解作用范围12345678910ElemetnType.TypeType-&gt;PACKAGE-包TYPE-类、接口、枚举值、Annotation类型 类型成员： 1.CONSTRUCTOR-构造器 2.FELD-描述域/字段 3.METHOD-描述方法LOCAL_VARIABLE-描述局部变量PARAMETER-描述参数 @Retention-保留表示需要在什么级别保存该注释信息（生命周期）取值 RetentionPolicy | 作用/保留域 -|–SOURCE | 在源文件中有效/源文件保留CLASS | 在class文件中有效/class保留RUNTIME | 在运行时有效/运行时保留可以被反射机制读数 @Documente@Inheritedday6 5/1 2019 反射机制 在运行时加载、探知、使用、编译期间完全未知的类。程序运行时，可以动态加载一个只有名称的类，对于任意一个已加载的类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个属性和方法；加载完类后，在堆内存中，就产生了一个Class类型的对象(一个类只有一个Class对象)，这个对象包含了完整的累的结构信息。它的作用类似一个图纸的作用，这个对象就像是一面镜子，透过这个镜子看到类的结构，我们称之为反射。 反射的根源是Class类 反射可以用来干什么？ 动态加载类、动态获取类的信息（属性、方法、构造器） 动态构造对象 动态调用类和对象的任意方法、构造器 动态调用和处理属性 获取泛型信息 处理注解 java.lang.Class 一个类被加载后，JVM会创建一个对应该类的Class对象,类的整个结构信息会被放到对应的Class对象中 JDK简介Instance of the class (Class) represent classes and interfaces in a running Java application.Anenum type is a kind of class and an annotation type is a kind of interface.Every array also belongsto a class that is reflected as aobject that is shared by all arrays with the same element type and number of dimensions.The primitive Java types,and the keyword(void) are also represented as objects.译:Class类的实例代表了正在运行的java类和对象。一个枚举class是一个类一个注解class是一个接口。每个数组从属于一个类，且相同数据类型同时维度相同的类从属于同一个类(同样的hashcode)。基本数据类型同和void关键字同样被视为一个类 Class类对象的获取方式123Class clazz = Class.forName(&quot;path&quot;) -最常使用Class clazz = path.getclass()Class clazz = class.class day7 5/2 2019 ### 反射操作类的名称、属性、方法、构造器 - 反射创建对象 12345Class clazz = Class.forName(path);User u1 = (User)clazz.newInstance();or加上泛型 Class&lt;User&gt; clazz = (Class&lt;User&gt;) Class.forName(path)User u1 = clazz.newInstance(); 反射获取类的名称1234567try{ Class clazz = Class.forName(&quot;com.sdz.&quot;) String name = clazz.getName()； String simplename = clazz.getSimpleName();}catch (Exception e){ printStackTrace} 反射获取类的属性123Field f1 = clazz.getDeclaredField(String)Field fields = clazz.getDeclareField()- 反射获取类的注解 反射操作类的属性1234User u = clazz.newInstance();f1.setAccessible(true);//跳过安全检查，提高反射性能，大约是原来的4倍f1.set(u,&quot;孙东哲&quot;);//通过反射写属性System.out.printle(f1.get());//通过反射读属性 反射获取类的方法12Method m1 = clazz.getDeclaredMethod(&quot;getUname&quot;);Method[] methods = clazz.getDeclaredMethods(); 反射调用普通方法12User u = clazz.newInstance();m1.invoke(u,&quot;孙东哲&quot;); 反射获取类的构造器12Constructor c1 = clazz.getDeclaredConstructor(int.class,int.class,String.class);Constructor[] constructors = clazz.getDeclaredConstructors(); 反射调用构造方法12User u = clazz.newInstance();//无参构造器c1.newInstance(1001,18,孙东哲); 反射的性能 反射的速度很慢，大约是普通方法调用的30倍但是如果跳过反射的安全检查，反射的速度可以增加4倍 反射操作泛型Java中泛型是给编译器看的，即生命周期仅限于编译期间所以 ，Java增加了ParameterizedType，GenericArrayType,TypeVariable,WildcardType几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型 ParameterizedType(参数化类型)例如：Collection GenericArrayType表示一种元素类型是参数化类型或者类型变量的数组类型 TypeVariable是各种类型变量的公共父接口 WildcardType 代表一种通配符类型表达式，比如？，？extends Number，？super Integer 反射操作注解12345678910111213141516try { //获取Class对象 Class clazz = Class.forName(&quot;com.bjsxt.test.annotation.SxtStudent&quot;); //获得类的所有有效注解 Annotation[] annotations=clazz.getAnnotations(); for (Annotation a : annotations) { System.out.println(a); } //获得类的指定的注解 SxtTable st = (SxtTable) clazz.getAnnotation(SxtTable.class); System.out.println(st.value()); //获得类的属性的注解 Field f = clazz.getDeclaredField(&quot;studentName&quot;); SxtField sxtField = f.getAnnotation(SxtField.class); System.out.println(sxtField.columnName()+&quot;--&quot;+sxtField.type()+&quot;--&quot;+sxtField.length()); //根据获得的表名、字段的信息，拼出DDL语句，然后，使用JDBC执行这个SQL，在数 据库中生成相关的表} catch (Exception e) {e.printStackTrace();} IO流文件创建 mkdir() mkdir() List() day3 5/14 2019 final和conset的区别final 修饰的变量定义时就需要初始化但是他的值是在运行时确定例如 1int final a = fn(); const 修饰的变量在编译时就被确定了 day1 5/25 2019 Java的回调函数 回调函数是由指针实现的，即在特定的事件或条件发生时由另外的一方调用的，作为该事件或条件的响应 而java中删除了指针的概念，但是可以通过接口和内部类来实现回调的功能： 步骤 1 定义接口Callback，包含回调方法callback() 2 在一个类Caller中声明一个Callback接口对象mCallback 3 在程序中赋予Caller对象的接口成员(mCallback)一个内部类对象例如12345new Callback(){ callback(){ //具体实现 }} 这样就可以在需要的时候，用Caller对象的mCallback接口成员，调用callback()方法，完成回调。 总结 1 声明回调函数的统一接口(实现可以不同)interface A，包含func() 2 在调用类caller中将该接口设置为私有成员private A xxx; 3 在caller内提供一个public的方法，可以将外部“改接口的实现类的引用”通过形参传给XXX; 4 caller的某个方法call()中会用到xxx.fun()方法； 5 在caller的实例中，将实现了A接口的对象的引用传给caller，后调用caller()方法 day10 6/7 2019 单例模式 1.懒汉式 2.恶汉式 3.双重锁模式 4.静态内部类实现 5.枚举实现 uml绘制 rational rose metamill 工厂模式原则 1.OCP开闭原则 2.DIP依赖倒置原则 3.LoD迪米特原则 简单工厂模式方法工厂模式抽象工厂模式原型模式适配器模式 day11 6/16 2019 桥接模式针对不稳定的情况(解决多继承，多个维度) 组合模式 关键 对整个树结构里的部分对象和整体对象都是一个统一的处理模式. 在其中有天然的递归 装饰模式针对稳定的，增加新的功能 外观模式封装 享元模式 1内部状态 可共享 2外部状态相似或相同对象——》 优点 1 减少对象数量，节省内存2 外部状态相对独立 缺点 1 模式较复杂2 节省运行时间 责任链模式（chain of responsibility)代替大量的if else 语句 处理同一类请求的对象 迭代器模式 (iterator)/游标模式cursor提供一种可以遍历聚合对象的方式通常以内部类的形式出现在聚合对象，便于操作外部对象JDK中的set/List等会使用 中介者模式 (Mediator)应对复杂结构 day12 8/6 2019 枚举类枚举是一个特殊的类,域成员均为常量命名时在结尾加上Enum 如:ProcessStatusEnum变量全部用大写并用下划线隔开","link":"/2019/11/28/java%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"},{"title":"mysql 登录失败","text":"mysql -u root -p报错 ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/tmp/mysql.sock’ (2) 这是因为mysql服务没有启动启动命令如下 mysql.server startorbrew services start mysql","link":"/2020/01/29/mysql-%E7%99%BB%E5%BD%95%E5%A4%B1%E8%B4%A5/"},{"title":"简简单单的Handler源码分析","text":"Handler机制如何保证线程之间的通信 Handler采用了内存共享的方案来实现线程间的进程通信, 为什么这么说呢? 接下来我会简单的分析一下. 在Handler机制中有下面几个类起到关键作用 MessageMessage是Handler机制中最基础的类, 也是需要”new”最多的类, 由于在Java中大量创建对象的操作会引起内存的碎片化, 可能会大对象(例如Bitmap)的空间申请造成困难从而诱发JVM进行频繁的GC以致于影响app性能, 当然还存在内存抖动等问题.对此, Google的Android工程师是通过一个对象池复用机制来减少以上问题. 所以当我们需要一个Message对象的时候就可以通过Message.obtain方法. 当我们”使用完”一个Message的时候, 也就是looper准备去获取下一个Message之前会将Message回收掉. 1msg.recycleUnchecked(); MessageQueueMessageQueue这个类是实现整个Handler机制的关键, 也是内存共享的核心, 在生产消费者模型中属于仓库的位置. 而且, 在它的next方法和enqueueMessage方法中调用了native方法来让线程让出时间片和尝试唤醒线程保证了线程的正常运转, 而在native层c++代码会去调用linux系统的相关服务,这里就不再深入了. HandlerHandler是一个Message的起始也是终止的地方. 如果把Message的传递简单看成生产消费者模型, 那么它既是生产者也是消费者.关于Handler对Message消息的处理进行了三层分级 检查 msg.callback 检查 mCallbackmCallback.handleMessage(msg); handleMessage这种类似责任链模式的处理方式极大的提高了程序的灵活性, 在View的事件分发过程中也有体现. LooperLooper它是一个比较特殊的类, 这里说的是它的设计思想很巧妙, 也可以说它是ThreaLocal类在Android中的最佳实践.因为它的一系列设计保证了Looper—&gt;MessageQue的线程隔离和线程内单例. 这里不得不说一下ThreadLocal这个类, 由于Thread类中内置了ThreadLocalMap对象, 让它天然就具有实现线程的隔离的可能.它利用了ThreadLocalMap的Key(ThreadLocal变量本身, 这里采用了hash函数去效验)是唯一的这一特性, 在myLooper方法中使用了一种伪单例的方式(直接抛出错误)禁止开发者去重复创建它的实例.这样以来它在私有构造方法中实例化的MessageQueue也得到了唯一性的保证.prepareLoop方法loop方法 从sendMessage/postMessage出发不管是从sendMessage从还是从post方法最终都会调用到Handler.enqueueMessage方法, 接着会调用Handler对应MessageQueue.enqueueMessage方法(Looper和MessageQueue都与Handler存在1对&gt;=1的关系). 而且这个入队方法考虑了线程安全问题(毕竟Handler本身就是用与线程通信嘛)对大部分的代码都加了sycronized锁. 在队列的另外一头, looper所在的线程需要要去开启loop去轮询消息队列.所以首先这里先从Looper.loop方法入手, loop方法首先去做了一些验证 主线程的Looper开启过程 主线程(ActivityThread)创建时(main方法)就创建了looper并调用了looper的loop方法 sendMessage和postMessage最终会调用SendMessage的方法 sendMessage =&gt; MessageQueue.enqueueMessage(msg,uptimeMills) 主线程中开启的Looper为什么不会导致ANR 因为在不需要无限循环的时候(如队列中没有可以处理的消息(消息设定的处理时间还没到或者队列中没有消息)就会阻塞线程直到有新的可以处理的消息就会去唤醒主线程. 如何避免Looper的内存泄漏问题在Looper的生命周期应该结束的时间点去调用它的quitSafely方法 Handler中使用到了哪些设计模式享元模式 在looper中会调用recycleUnckecked方法进行回收利用 责任链模式 通过分发Message进行分层处理,极大的提高了程序的灵活性.","link":"/2020/05/25/%E7%AE%80%E7%AE%80%E5%8D%95%E5%8D%95%E7%9A%84Handler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"title":"简简单单的OkHttp源码分析","text":"OkHttp介绍 OkHttp是目前Android使用最频繁的网络请求框架(目前的Volley, Retrofit底层都是使用的OkHttp), 框架由Square公司开源, 在Android4.4之后HttpUrlConnection也默认使用OkHttp的实现在OkHttp4之后改为kotlin实现 优势所在 支持Socket连接池复用TCP连接 支持Http2.0协议 支持Gzip压缩格式 支持缓存控制 请求失败时的自动重试和重定向机制 OkHttp的分发器对于同步请求, 直接加入runningAsyncCalls队列当中 而同步请求对于请求次数不超过64次, 同主机不超过的5次的请求直接加入到runningAsyncCalls队列当中, 如果不符合条件则加入到readAsyncCalls中 默认的五个拦截器的职责重试与重定向拦截器在发生一次请求超时的情况下, 去寻找可用的ip重新请求服务器.某次请求返回了30x时, 并且在响应报文头的Location字段中有重定向的url, 则根据这个url重新构建一个Request 重试 重定向 桥接拦截器为request补充请求头等信息提供cookie, 如果用户需要cookie会在这里进行处理 缓存拦截器请求前查询是否有可用缓存, 如果缓存有效, 则直接返回缓存 连接拦截器与服务器完成TCP连接 请求服务拦截器与服务器通信;封装请求数据与解析响应对于已经取消的请求结果不再返回客户端 如果在通过重试与重定向拦截器之后取消了任务, 取消是否无效仍然会去请求, 但是用户不会接收到响应","link":"/2020/05/25/%E7%AE%80%E7%AE%80%E5%8D%95%E5%8D%95%E7%9A%84OkHttp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"title":"简简单单的Retrofit源码分析","text":"Retrofit做了什么 Retrofit 对 OkHttp进行了一层封装, 对网络层进行了解耦, 主要是通过注解,泛型,动态代理, 还有大量的设计模式来实现的. Retrofit使用流程分析 构建一个Retrofit对象 123456789val retrofit = Retrofit.Builder()//Retrofit2的baseUrl 必须以 /(斜杆)结束，抛出一个IllegalArgumentException.baseUrl(&quot;https://www.wanandroid.com/&quot;).addConverterFactory(GsonConverterFactory.create()).build() 通过建造者模式构建对象可以灵活添加、修改功能如自定义OkHttpClient, 自定义转换器, 自定义适配器 通过Retrofit对象获取到api接口的代理对象 12//2. 获取WanAndroidApi接口的代理对象val wanAndroidApi = retrofit.create(WanAndroidApi::class.java) ​ 使用动态代理模式返回一个代理对象, 这里的Api需要提前定义好. 123456789101112131415161718return (T) Proxy.newProxyInstance( service.getClassLoader(), new Class&lt;?&gt;[] {service}, new InvocationHandler() { private final Platform platform = Platform.get(); private final Object[] emptyArgs = new Object[0]; @Override public @Nullable Object invoke(Object proxy, Method method, @Nullable Object[] args)throws Throwable { if (method.getDeclaringClass() == Object.class) { return method.invoke(this, args);// Object的方法不属于接口, 直接调用 } args = args != null ? args : emptyArgs; return platform.isDefaultMethod(method) ? platform.invokeDefaultMethod(method, service, proxy, args) : loadServiceMethod(method).invoke(args);// 在这里去解析注解信息, 然后调用 } }); 通过代理对象去调用Api中提供的请求方法 12//3. 获取具体的请求业务方法val projectCall = wanAndroidApi.getProject() ​ 调用这个代理对象的方法时会调用到InvocationHandler中的invoke当中, 在里面会去调用loadServiceMethod方法去解析接口的注解参数得到一个ServiceMethod对象, 并将它保存存到ServiceMethodCahce当中, 以便下次调用的时候可以进行复用, 减少反射带来的开销. 然后接着去调用ServiceMethod的invoke方法, 返回一个Retrofit的Call对象, 里面包了一个真正的OkHttpCall对象和http请求参数以及一些适配器,转换器 发送一个同步/异步请求 123456789101112//4. 发起请求 // 同步// val projectBean = projectCall.execute() //异步 projectCall.enqueue(object : Callback&lt;ProjectBean&gt; { override fun onFailure(call: Call&lt;ProjectBean&gt;, t: Throwable) { Log.i(TAG,&quot;错误：${t.message}&quot;) } override fun onResponse(call: Call&lt;ProjectBean&gt;, response: Response&lt;ProjectBean&gt;) { Log.i(TAG,&quot;成功： ${response.body().toString()}&quot;) }}) 这里可以传入一个接口回调, 默认配置情况下会使用DefaultCallAdapterFactory创建的Call, 也可以配合RxJava进行使用. 然后会调用到OkHttpCall的enqueue, 请求返回后OkHttp会去回调刚刚传入的接口回调 12345678910111213public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) { Response&lt;T&gt; response; response = parseResponse(rawResponse); ... callback.onResponse(OkHttpCall.this, response); ...}private void callFailure(Throwable e) { ... callback.onFailure(OkHttpCall.this, e); ...} 关键类分析Retrofit1. serviceMethodCache(缓存的完整的调用, 对应一个url) 2. baseUrl (地址) 3. callFactory 4. converterFactories(数据解析) 5. callAdapterFactories(适配器) 6. callbackExecutorPlatform(平台)Platform使用恶汉式单例提供它的实例 如果是Dalvik虚拟机提供Android平台, 否则提供Java(8)平台 CallRetrofit中定义的网络请求接口 OkHttpCallOkHttp的Call实现, 可以通过getRawCall拿到okhttp3.Call对象 CallAdapter.FactorycalllAdapter静态工厂, 生产CalllAdapter对象 设计模式 建造者模式 Retrofit, ServiceMethod对象的创建都用到了建造者模式, 简化了复杂对象的创建过程 外观模式 Retrofit对外提供了统一的接口, 屏蔽了内部实现, 使用更加简单. 简单的说就是通过提供一个高层接口去间接访问到子系统的不同接口, 类似一个接口整合的过程 动态代理模式 通过生成一个代理对象, 并对代理对象进行监听, 当执行方法的时候自动回调到invocationHandler中. 静态代理模式 Android平台默认使用DefaultCallbackFactory.ExecutorCallback, 具体实现delegate就是OkHttpCall 工厂模式 Converter和CallAdapter的创建过程都是使用工厂模式来实现的 适配器模式 看名字就知道CallAdapter.adapt使用了适配器模式, 可以对call进行动态扩展, 添加回调、观察者都可以","link":"/2020/05/25/%E7%AE%80%E7%AE%80%E5%8D%95%E5%8D%95%E7%9A%84Retrofit%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"title":"配置OpenCV","text":"Cmake编译Opencv 国庆期间配置了下开发环境,记录一下遇到的坑 一、安装MinGW-64 用于编译opencv库 下载MinGW-64 直接安装即可,注意选择x86_64架构,我选择的是7.3.0版本 另外添加环境变量 可以用 gcc -v 和g++ -v检查 二、 安装cmake下载cmake 安装 配置环境变量 可以用cmake –version检查 三、 安装clion JetBrains家的一款c(c++)IDE 默认安装即可 激活码1812LFWMRSH-eyJsaWNlbnNlSWQiOiI4MTJMRldNUlNIIiwibGljZW5zZWVOYW1lIjoi5q2j54mIIOaOiOadgyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwiZmFsbGJhY2tEYXRlIjoiMjAxOS0wNC0yMSIsInBhaWRVcFRvIjoiMjAyMC0wNC0yMCJ9LHsiY29kZSI6IkFDIiwiZmFsbGJhY2tEYXRlIjoiMjAxOS0wNC0yMSIsInBhaWRVcFRvIjoiMjAyMC0wNC0yMCJ9LHsiY29kZSI6IkRQTiIsImZhbGxiYWNrRGF0ZSI6IjIwMTktMDQtMjEiLCJwYWlkVXBUbyI6IjIwMjAtMDQtMjAifSx7ImNvZGUiOiJQUyIsImZhbGxiYWNrRGF0ZSI6IjIwMTktMDQtMjEiLCJwYWlkVXBUbyI6IjIwMjAtMDQtMjAifSx7ImNvZGUiOiJHTyIsImZhbGxiYWNrRGF0ZSI6IjIwMTktMDQtMjEiLCJwYWlkVXBUbyI6IjIwMjAtMDQtMjAifSx7ImNvZGUiOiJETSIsImZhbGxiYWNrRGF0ZSI6IjIwMTktMDQtMjEiLCJwYWlkVXBUbyI6IjIwMjAtMDQtMjAifSx7ImNvZGUiOiJDTCIsImZhbGxiYWNrRGF0ZSI6IjIwMTktMDQtMjEiLCJwYWlkVXBUbyI6IjIwMjAtMDQtMjAifSx7ImNvZGUiOiJSUzAiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA0LTIxIiwicGFpZFVwVG8iOiIyMDIwLTA0LTIwIn0seyJjb2RlIjoiUkMiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA0LTIxIiwicGFpZFVwVG8iOiIyMDIwLTA0LTIwIn0seyJjb2RlIjoiUkQiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA0LTIxIiwicGFpZFVwVG8iOiIyMDIwLTA0LTIwIn0seyJjb2RlIjoiUEMiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA0LTIxIiwicGFpZFVwVG8iOiIyMDIwLTA0LTIwIn0seyJjb2RlIjoiUk0iLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA0LTIxIiwicGFpZFVwVG8iOiIyMDIwLTA0LTIwIn0seyJjb2RlIjoiV1MiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA0LTIxIiwicGFpZFVwVG8iOiIyMDIwLTA0LTIwIn0seyJjb2RlIjoiREIiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA0LTIxIiwicGFpZFVwVG8iOiIyMDIwLTA0LTIwIn0seyJjb2RlIjoiREMiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA0LTIxIiwicGFpZFVwVG8iOiIyMDIwLTA0LTIwIn0seyJjb2RlIjoiUlNVIiwiZmFsbGJhY2tEYXRlIjoiMjAxOS0wNC0yMSIsInBhaWRVcFRvIjoiMjAyMC0wNC0yMCJ9XSwiaGFzaCI6IjEyNzk2ODc3LzAiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-ti4tUsQISyJF/zfWxSHCr+IcYrX2w24JO5bUZCPIGKSi+IrgQ0RT2uum9n96o+Eob9Z1iQ9nUZ6FJdpEW5g0Exe6sw8fLrWMoLFhtCIvVgQxEEt+M7Z2xD0esmjP1kPKXZyc/i+NCxA2EO2Sec9uifqklBGP1L3xoENAw2QsIWBfttIe6EPWhbS8TIMMr2vF/S3HrN8To5Hj5lwD/t1GHgFK1uWrhsuifAiKcVzqogybzGiR1h2+yNYTMbKxP7uPCcdYMsIyrBNVRGA3IuEJgyGQTQlFbnVQoVUTGPW2tQxprmC464wMjKi40JHh27WzjOHPwgzxDaigwn4Z0EbSpA==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQAF8uc+YJOHHwOFcPzmbjcxNDuGoOUIP+2h1R75Lecswb7ru2LWWSUMtXVKQzChLNPn/72W0k+oI056tgiwuG7M49LXp4zQVlQnFmWU1wwGvVhq5R63Rpjx1zjGUhcXgayu7+9zMUW596Lbomsg8qVve6euqsrFicYkIIuUu4zYPndJwfe0YkS5nY72SHnNdbPhEnN8wcB2Kz+OIG0lih3yz5EqFhld03bGp222ZQCIghCTVL6QBNadGsiN/lWLl4JdR3lJkZzlpFdiHijoVRdWeSWqM4y0t23c92HXKrgppoSV18XMxrWVdoSM3nuMHwxGhFyde05OdDtLpCv+jlWf5REAHHA201pAU6bJSZINyHDUTB+Beo28rRXSwSh3OUIvYwKNVeoBY+KwOJ7WnuTCUq1meE6GkKc4D/cXmgpOyW/1SmBz3XjVIi/zprZ0zf3qH5mkphtg6ksjKgKjmx1cXfZAAX6wcDBNaCL+Ortep1Dh8xDUbqbBVNBL4jbiL3i3xsfNiyJgaZ5sX7i8tmStEpLbPwvHcByuf59qJhV/bZOl8KqJBETCDJcY6O2aqhTUy+9x93ThKs1GKrRPePrWPluud7ttlgtRveit/pcBrnQcXOl1rHq7ByB8CFAxNotRUYL9IF5n3wJOgkPojMy6jetQA5Ogc8Sm7RG6vg1yow== 四、编译opencv 这里是用的是opencv3.2 下载opencv 选择对应平台下载并解压 打开cmake where is the source code选择source文件夹 where is the binaries 选择 新建的mingw64-build文件夹 注意上面两个路径不能含有中文目录结构,否则后面会报错 configure 等待配置 configure 等待配置 Gernerate 生成 cmd进入mingw64-build路径 输入 mingw32-make -j8 输入 mingw32-make install 将mingw64下的bin目录配置到环境变量","link":"/2019/11/28/%E9%85%8D%E7%BD%AEOpenCV/"},{"title":"iOS学习计划（实验）","text":"iOS学习计划（实验） 一个不成熟的iOS初学者学习规划 了解全局 确定范围掌握基础知识 完成一个天气页面 UI布局 LinearLayout textview icon imageview menuitem button 网络请求 存储 Objective-C 定义目标完成天气页面 了解需要的技术点 寻找资源信息来源 图书 ios 编程实战 ios高级编程 effective-OC 博客文章 sf非常详细 在线视频 Lynda ios14 专家 源代码 示例项目 在线文档 Document Archieve raywenderlick 创建学习计划学习oc ​ blocks 学习UI布局 UIKit 自动布局 学习操纵页面路由 学习网络请求（ps：找一个天气api） 学习sqlite在ios上的使用 完成天气页面 筛选资源以下步骤重复执行 开始学习 浅尝搁置获得足够多的与所学主题相关的东西（最小知识量：参考材料，摘要，简介） 动手操作亲自操作和亲身体验，通过探索和实践进行学习。 在操作的过程中产生各种问题？这些问题引导着你走向真正重要的方向。 回过头寻找问题的答案，learn more 采用上一步的学到的知识，不用担心结果，先创建一个小项目来测试这一步的效果。 把那些暂时还没有答案的问题记录下来，你在下一步中会有机会找出这些问题的答案。 全面掌握 学以致用 找回失去的好奇心 在上一步中积累的问题，可以通过阅读相关主题的资料来回答这些问题。你可以通览已有的资料，仔细查找通过操作发现的问题有关的内容。 阅读文字 观看视频 与他人交流 请记住，你依然没有必要把收集到的资料全部仔细看一遍。你只需要阅读或观看与当前所学相关的部分。 最后，请不要忘记你在第三步定义的成功标准。把自己正在学习的内容与最终目标关联起来。你掌握的每个模块，都应该以某种方式推动你向着终极目标前进。。 乐为人师，融会贯通 你告诉我的，我都忘了。你教会我的，我都记得。让我乐在其中，我就一定能学会。 ​ —本杰明·富兰克林 走出舒适区，将自己学到的知识教给别人。要想确定你确实掌握了某些知识，这是唯一的办法。同时，也是查缺补漏的好办法； 在这一过程中，你要切实剖析并理解自己所学的知识，将其内化到自己的思想； 同时，你也要能够同他人能够理解的方式精心组织这些信息，这也有助于提升你的理解能力。 写博客 制作视频 与朋友/爱人探讨 发表演讲 在线论坛回答问题","link":"/2021/01/20/ios%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92%EF%BC%88%E5%AE%9E%E9%AA%8C%EF%BC%89/"},{"title":"iOS网络请求 NSURLConnection","text":"iOS网络请求 NSURLConnection URLConnection的几种用法 123456/*触发*/- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event{ [self async];} 1234567891011121314151617181920212223/** Get请求-同步 */- (void) sync{ NSURL* url = [NSURL URLWithString:@&quot;https://tianqiapi.com/api?version=v1&amp;appid=53827541&amp;appsecret=sIY6i0fQ&quot;]; NSURLRequest *request = [[NSURLRequest alloc]initWithURL: url]; NSHTTPURLResponse * response = **nil**; NSData *data = [NSURLConnection sendSynchronousRequest:request returningResponse: &amp;response error: **nil**]; NSLog(@&quot;%@&quot;,[[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]); NSLog(@&quot;%zd&quot;,response.statusCode);} 12345678910111213141516171819202122/** Get请求-同步 */- (void)async{ NSURL* url = [NSURL URLWithString:@&quot;https://tianqiapi.com/api?version=v1&amp;appid=53827541&amp;appsecret=sIY6i0fQ&quot;]; NSURLRequest *request = [[NSURLRequest alloc]initWithURL: url]; [NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * *connectionError) { NSString *result = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]; result = [self stringByReplaceUnicode:result]; NSLog(@&quot;%@&quot;,result); NSHTTPURLResponse* res = (NSHTTPURLResponse*)response; NSLog(@&quot;%zd&quot;,res.statusCode); }];} 12345678910111213141516171819202122232425262728293031323334/*Get请求-代理*///实现协议 &lt;NSURLConnectionDataDelegate&gt;- (void)delegate{ NSURL* url = [NSURL URLWithString:@&quot;https://tianqiapi.com/api?version=v1&amp;appid=53827541&amp;appsecret=sIY6i0fQ&quot;]; NSURLRequest *request = [[NSURLRequest alloc]initWithURL: url]; [NSURLConnection connectionWithRequest:request delegate:self];}/*协议对应的方法*/#pragma mark -NSURLConnectionDataDelegate- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response{ NSLog(@&quot;%s&quot;,__func__);}- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data{ NSLog(@&quot;%s&quot;,__func__); [self.resultData appendData:data];}- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error{ NSLog(@&quot;%s&quot;,__func__);}- (void)connectionDidFinishLoading:(NSURLConnection *)connection{ NSLog(@&quot;%s&quot;,__func__); NSLog(@&quot;%@&quot;,[[NSString alloc]initWithData:_resultData encoding:NSUTF8StringEncoding]); }","link":"/2021/01/22/ios%E5%BC%80%E5%8F%91-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-NSURLConnection/"},{"title":"重启尘封的博客","text":"时隔2年半，俺又回来更新博客了，以后每周一或者周二会在博客上发布上一周的周报~","link":"/2023/07/17/%E9%87%8D%E5%90%AF%E5%B0%98%E5%B0%81%E7%9A%84%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"生活","slug":"生活","link":"/tags/%E7%94%9F%E6%B4%BB/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"OpenCV","slug":"OpenCV","link":"/tags/OpenCV/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"}],"categories":[]}